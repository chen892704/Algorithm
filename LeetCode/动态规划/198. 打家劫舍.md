# 198. 打家劫舍
> 来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/house-robber/description/

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

## 解题思路
### 解法一：回溯
使用选 or 不选的思路，枚举每个元素：
- 若选择该房间，则递归枚举 i+2 个房间
- 若不选择，则递归枚举 i+1 个房间

*该解法在本题中会超时 (55/70)*

### 解法二：记忆化搜索
在回溯的过程中，实际上是对一颗二叉树的遍历，会重复遍历某一个子树
- 从后往前观察回溯过程，可得到递推公式 `dfs(i) = max(dfs(i-2) + nums[i], dfs(i-1))`
- 使用 dp 数组存储前 i 个数的最大结果，可以空间换时间优化复杂度

### 解法三：从前往后(自底向上)递推
递推公式 `dp[i] = max(dp[i-2] + nums[i], dp[i-1])`
- 观察递推公式可发现，在从前到后的枚举过程中，实际上计算只需要知道 `dp[i-2]` 和 `dp[i-1]` 两个状态
- 优化 dp 数组，递归修改为循环从前到后递推，只需要两个变量递可推出最终结果

最终解法即与计算斐波那契数列解法相同；实际计算中，假设数组前面多两个值为 0 的元素，方便编写代码

## 代码实现
### 解法一
时间复杂度 O(2^n)，空间复杂度 O(n)
```cpp
class Solution {
public:
    int sum = 0;
    int res = 0;
    int n = 0;

    void dfs(vector<int>& nums, int index) {
        if (index >= n) {
            res = max(sum, res);
            return;
        }

        // 选
        sum += nums[index];
        dfs(nums, index+2);
        sum -= nums[index];
        // 不选
        dfs(nums, index+1);
    }

    int rob(vector<int>& nums) {
        n = nums.size();
        dfs(nums, 0);
        return res;
    }
};
```
另一种写法，从后往前 (自顶向下)
```cpp
class Solution {
public:
    int n = 0;

    int dfs(vector<int>& nums, int index) {
        if (index < 0) {
            return 0;
        }

        // 选 or 不选
        return max(dfs(nums, index-2) + nums[index], dfs(nums, index-1));
    }

    int rob(vector<int>& nums) {
        n = nums.size();
        return dfs(nums, n-1);
    }
};
```

### 解法二
时间复杂度 O(n), 空间复杂度 O(n)
```cpp
class Solution {
public:
    int n = 0;

    // 记忆化搜素, 记录前 i 个数的最大结果
    vector<int> dp;

    int dfs(vector<int>& nums, int index) {
        if (index < 0) {
            return 0;
        }

        // 记录当前 index 结果防止重复计算
        if (dp[index] < 0) {
            // 选 or 不选
            dp[index] = max(dfs(nums, index-2) + nums[index], dfs(nums, index-1));
        }
        return dp[index];
    }

    int rob(vector<int>& nums) {
        n = nums.size();
        dp.resize(n, -1);
        return dfs(nums, n-1);
    }
};
```

### 解法三
时间复杂度 O(n), 空间复杂度 O(1)
```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        // 假设数组前面多两个 0
        int f1 = 0, f2 = 0;
        for (int i = 0; i<nums.size(); ++i) {
            // dp[i] = max(dp[i-2] + nums[i], dp[i-1]);
            int tmp = max(f1 + nums[i], f2);
            f1 = f2;
            f2 = tmp;
        }
        
        return f2;
    }
};
```