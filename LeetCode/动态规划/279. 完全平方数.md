# 279. 完全平方数
> 来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/perfect-squares/description

给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

## 解题思路
本题为完全背包问题

### 解法一：回溯
定义 `int dfs(i,j)`，其返回值表示在 1~i 的完全平方数中选择 n 个数，值恰好为 j 的最少个数，使用选 or 不选的思路，枚举每个元素：
- 不选，则递归 `dfs(i-1, j)`，总和无变化，枚举 i-1
- 选，则递归 `dfs(i, j)`，计数 + 1（这里递归仍是 i，因为可以重复选）
- 特殊的，如果 `j < i^2` 则当前 i 无法选，直接递归 `dfs(i-1,j)`
- 当 `i == 0` 枚举完成结束递归，此时：
    1. 若 `j == 0` 则该分支方案可行，返回 0 （即 dfs(0, 0) 的结果，从 0 个数中取 n 个和为 0 的数字，答案是 0）
    2. 否则该分支不可行，返回 INT_MAX 以过滤掉该分支

在选与不选两种分支中，取其最小数即为答案，递推公式即: `dfs(i, j) = min(dfs(i-1, j), dfs(i, j-i*i) + 1)`

*同 LC 198，直接回溯会超时*

### 解法二：记忆化搜索
使用 dp 数组记录结果, 优化重复递归调用

### 解法三：从前往后(自底向上)递推


## 代码实现
### 解法一
时间复杂度 O(n*sqrt(n))，空间复杂度 O(n)
```cpp
class Solution {
public:
    // 返回值 = 从前 i 个完全平方数中选，元素和恰好为 j 的最少数字个数
    int dfs(int i, int j) {
        // i 遍历完了
        if (i == 0) {
            if (j == 0) 
                return 0; // 和恰好为 j, 返回 dfs(0,0) = 0, 当前分支可行
            else
                return INT_MAX; // 不满足恰好为 j, 返回最大值, 即当前分支不通
        }

        // 不够了只能不选
        if (j < i*i) {
            return dfs(i-1, j);
        }

        // 当前元素选 or 不选
        return min(dfs(i, j-i*i) + 1, dfs(i-1, j));
    }

    int numSquares(int n) {
        return dfs(sqrt(n), n);
    }
};
```

### 解法二
时间复杂度 O(n), 空间复杂度 O(n)
```cpp
class Solution {
public:
    vector<vector<int> > memo;

    // 返回值 = 从前 i 个完全平方数中选，元素和恰好为 j 的最少数字个数
    int dfs(int i, int j) {
        // i 遍历完了
        if (i == 0) {
            if (j == 0) 
                return 0; // 和恰好为 j, 返回 dfs(0,0) = 0, 当前分支可行
            else
                return INT_MAX; // 不满足恰好为 j, 返回最大值, 即当前分支不通
        }

        int &res = memo[i][j];
        if (res != -1) { // 已经计算过
            return res;
        }

        // 不够了只能不选
        if (j < i*i) {
            res = dfs(i-1, j);
        }
        // 当前元素选 or 不选
        else {
            res = min(dfs(i, j-i*i) + 1, dfs(i-1, j));
        }
        return res;
    }

    int numSquares(int n) {
        int max = sqrt(n);
        memo.resize(max+1, vector<int>(n+1, -1));
        return dfs(max, n);
    }
};
```

### 解法三
时间复杂度 O(n), 空间复杂度 O(n)
```cpp
class Solution {
public:
    vector<vector<int> > memo;
    
    int numSquares(int n) {
        int max = sqrt(n);
        memo.resize(max+1, vector<int>(n+1, INT_MAX));

        memo[0][0] = 0;
        for (int i=1; i*i <= n; ++i) {
            for (int j=0; j<=n; ++j) {
                // 容量不足, 只能不选
                if (j < i*i) {
                    memo[i][j] = memo[i-1][j];
                }
                // 选 or 不选, 取 min
                else {
                    memo[i][j] = min(memo[i][j-i*i] + 1, memo[i-1][j]);
                }
            }
        }

        return memo[max][n];
    }
};
```