# 72. 编辑距离
> 来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/edit-distance/description

给你两个单词 `word1` 和 `word2`， 请返回将 `word1` 转换成 `word2` 所使用的最少操作数。

你可以对一个单词进行如下三种操作：
- 插入一个字符
- 删除一个字符
- 替换一个字符

## 解题思路
本题与 [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/description/) 解法类似
- 设两个单词为 `s`,`t`，定义 `dfs(i,j)` 为 `s` 前 `i` 个字符，转换至 `t` 前 `j` 个字符的最小操作数
- 从后向前枚举，当前 `s[i] == t[j]` 时，可以不用操作直接去掉这两个字符，缩小子问题，`dfs(i, j) = dfs(i-1, j-1)`
- 当前 `s[i] != s[j]` 时，则需要使用 插入、删除、替换操作之一，我们分别枚举这三个操作（即三选一），取其中最小值 + 1（操作次数 + 1）即为最少操作数：`dfs(i, j) = min(dfs(i-1, j), dfs(i, j-1), dfs(i-1, j-1)) + 1`
    - 插入 -- 即在 `s` 后插入一个 `t[j]` 与其抵消，t 长度减一
    - 删除 -- 即删除 `s[i]`，s 长度减一
    - 替换 -- 即将 `s[i]` 替换成 `t[j]`，s 和 t 长度都减一
- 边界处理：当其中一个字符串枚举完成
    - 若 `s` 枚举完成，则在 `s` 中插入 `t` 剩下的字符，操作数增加 `j+1`（j 为下标）
    - 若 `t` 枚举完成，则把 `s` 剩余字符删掉，操作数增加 `i+1`

## 代码实现
时间复杂度 O(m\*n)，空间复杂度 O(m\*n)
```cpp
class Solution {
public:
    int m = 0, n = 0;
    vector<vector<int> > memo;

    int dfs(string &s1, string &s2, int i, int j) {
        // 一个字符串处理完成，剩下的需要执行插入 or 删除补齐
        if (i < 0) {
            return j+1;
        }
        if (j < 0) {
            return i+1;
        }

        int &res = memo[i][j];
        if (res != -1) {
            return res;
        }

        // 当前 i,j 字符匹配, 缩小子问题
        if (s1[i] == s2[j]) {
            res = dfs(s1, s2, i-1, j-1);
        }
        // 当前不匹配，枚举 插入/删除/替换 三种操作的路径
        else {
            res = min(min(dfs(s1, s2, i-1, j), dfs(s1, s2, i, j-1)), dfs(s1, s2, i-1, j-1)) + 1;
        }

        return res;
    }

    int minDistance(string word1, string word2) {
        m = word1.length();
        n = word2.length();
        memo.resize(m, vector<int>(n, -1));
        return dfs(word1, word2, m-1, n-1);
    }
};
```
