# 79. 单词搜索
> 来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/word-search/description

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

## 解题思路
DFS 遍历图 + 回溯

* 以图中每个字母与单词首字母相同的坐标 i,j 开始，dfs 遍历图
* dfs 遍历中，若当前字母匹配单词对应位置 k 的字母，则继续 dfs 相邻的四个坐标，否则当前分支无结果直接返回 false
* 递归过程中，需过滤掉不在图中的坐标，以及遍历过的坐标（遍历过的修改值标记，在 dfs 返回后回溯）
* 若匹配完成（即 k == words.length）直接返回 true

优化：可行性剪枝

* 在 dfs 前先统计单词中字母出现的次数，是否小于图中对应字母存在个数，如果是则不可能有答案

## 代码实现
```cpp
class Solution {
public:
    string target = "";
    int rows = 0, cols = 0;
    vector<vector<int> > dirs = {{0,-1}, {0,1}, {-1,0}, {1,0}};

    bool dfs(vector<vector<char> >& board, int i, int j, int k) {
        if (k == target.size())
            return true;

        if (i < 0 || i > rows-1 || j < 0 || j > cols-1 || 
            board[i][j] == '0' || board[i][j] != target[k])
            return false;

        // 当前字符匹配, dfs 相邻节点
        for (auto& dir : dirs) {
            auto tmp = board[i][j];
            board[i][j] = '0';
            if (dfs(board, i+dir[0], j+dir[1], k+1)) {
                return true;
            }
            board[i][j] = tmp; // 回溯
        }
        return false;
    }

    bool hasAnswser(vector<vector<char> >& board, string word) {
        // 统计图和目标串的字母个数
        map<char, int> boardCount, wordCount;
        for (char c : word) {
            ++wordCount[c];
        }
        for (auto& row : board) {
            for (auto& c : row) {
                ++boardCount[c];
            }
        }

        // 若图中字母个数比目标串中还少, 则不可能有结果
        for (auto& ele : wordCount) {
            auto it = boardCount.find(ele.first);
            if (it == boardCount.end() || it->second < ele.second) {
                return false;
            }
        }
        return true;
    }

    bool exist(vector<vector<char> >& board, string word) {
        if (!hasAnswser(board, word)) {
            return false;
        }

        target = word;
        rows = board.size();
        cols = board[0].size();
        for (int i=0; i<rows; ++i) {
            for (int j=0; j<cols; ++j) {
                if (board[i][j] == word[0]) {
                    if (dfs(board, i, j, 0)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
};
```
