# 215. 数组中的第K个最大元素
> 来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/kth-largest-element-in-an-array

在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。

## 解题思路
经典的 Top K 问题，常用的解法有两种，利用了堆排/快排的思想

**解法一：** 
利用最大堆来找到第 K 大的元素

* 用数组前 K 个数建立一个大小为 K 的最小堆
* 继续遍历数组，当前元素与堆顶 top 比较，若大于 top 则替换它，重新调整堆
* 最后堆中剩下的数字就是 Top K，堆顶即为第 K 大的数

**解法二：**
利用了分治思想的快速选择 (quick select) 算法

* 使用快排的 partition 划分数组，划分完成后的基准 pivot 所在的位置即为数组有序后的位置
* 判断其位置 index（下标）和 K 的大小，若 K 比 index 大，则需要在右区间继续执行 partition；否则在左区间划分
* 当 index 与 K 相等时，当前基准 pivot 即为第 K 大的数字


2025.09.12：五年后的回顾，基于快排的快速选择，另一种写法
- 随机取一个基准数 x
- 以 x 来划分数组为三份，得到比 x 大的数组 big，值为 x 的数组 equal，比 x 小的数组 small
    - 此时数组 big 里有第 1 ~ `big.size` 大的数
    - 数组 equal 里有第 `big.size+1` ~ `big.size + equal.size` 大的数
    - 数组 small 则为第  `big.size + equal.size + 1` ~ `nums.size` 大的数
- 根据 k 的大小判断第 k 大的数字在哪个数组中，递归 big or small 数组继续缩小范围
- 若 k 在 equal 里，则找到了第 k 大的数就是 x


## 代码实现
**解法一：**
时间复杂度 O(nLogK) （建堆 O(n) + N 次调整堆 LogK），空间复杂度 O(k)
```cpp
// 默认是大根堆，需要定义小根堆
struct Node 
{
    int value;
    Node (int v): value(v) {}
//  friend bool operator < (const struct Node &n1, const struct Node &n2) ;
    friend bool operator > (const struct Node &n1, const struct Node &n2) ;
}; 

inline bool operator > (const struct Node &n1, const struct Node &n2) 
{
    return n1.value > n2.value;
}

// priority_queue 定义，底层是一个 vector，传入谓词时还需要传入 Container 参数
// template <class T, class Container = vector<T>, 
//   class Compare = less<typename Container::value_type> > class priority_queue;

class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) 
    {
        int nSize = nums.size();
        // 建立最小堆
        priority_queue<Node, vector<Node>, greater<Node> > que;
        for (int i=0 ; i<k; ++i)
        {
            que.push(nums[i]);
        }
        for (int i=k; i<nSize; ++i)
        {
            if (nums[i] > que.top())
            {
                que.pop();
                que.push(nums[i]);
            }
        }
        return que.top().value;
    }
};
```

**解法二：**
时间复杂度 **平均** O(n)，**最坏** O(n^2))，空间复杂度 O(1) 
```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) 
    {
        // assert(!nums.empty())
        return helper(nums, 0, nums.size()-1, nums.size()-k);
    }

private:
    int helper(vector<int> & nums, int low, int high, int pos)
    {
        int pivot = partition(nums, low, high);
        if (pos > pivot)
            return helper(nums, pivot+1, high, pos);
        else if (pos < pivot)
            return helper(nums, low, pivot-1, pos);
        else
            return nums[pivot];
    }
    // 快排的划分函数
    int partition (vector<int> & nums, int low, int high)
    {
        int pivot = nums[low];
        while (low < high)
        {
            while (low < high && nums[high] >= pivot)
                --high;
            nums[low] = nums[high];
            while (low < high && nums[low] <= pivot)
                ++low;
            nums[high] = nums[low];
        }
        nums[low] = pivot;
        return low;
    }
};
```

2025.09.12：五年后的回顾，期望这次也能找到心仪的工作
```cpp
class Solution {
public:
    // 基于快排的快速选择
    int quickSelect(vector<int>& nums, int k) {
        // 随机选择基准数
        int x = nums[rand() % nums.size()];

        // 以基准数将数组划分
        vector<int> small, equal, big;
        for (int i : nums) {
            if (i < x) {
                small.push_back(i);
            }
            else if (i == x) {
                equal.push_back(i);
            }
            else {
                big.push_back(i);
            }
        }

        // 递归划分数组找到第 K 位的数

        // big 里是第 1 到第 big.size() 大的数
        if (k <= big.size()) {
            return quickSelect(big, k);
        }
        // k 比前 N 大的数小（N = big.size + equal.size），在 small 里
        if (k > big.size() + equal.size()) {
            // 原数组中第 k 大的数，在 small 里是第 (k - 比 small 里都大的数的个数）
            return quickSelect(small, k - (big.size() + equal.size()));
        }

        // 第 k 大数在 equal 中，x 即为答案
        return x;
    }

    int findKthLargest(vector<int>& nums, int k) {
        return quickSelect(nums,k);
    }
};
```


