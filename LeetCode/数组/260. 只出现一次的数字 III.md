# 260. 只出现一次的数字 III
> 来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/single-number-iii

给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。

## 解题思路
一般的解法可以排序、或者使用 set 来找到没有重复的数字，不过这类解法都需要额外的辅助空间

如果想实现O(n) 时间，O(1) 空间的解法，要用位运算来实现

**异或的性质:**

两个数字异或的结果 a^b 是将 a 和 b 的二进制每一位进行运算，得出的数字。
运算的逻辑是如果同一位的数字相同则为 0，不同则为 1

**异或的规律:**

* 任何数和本身异或则为 0
* 任何数和 0 异或是本身
* 异或满足交换律，即 a ^ b ^ c ，等价于 a ^ c ^ b

------

在 [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/) 中，对于数组中全部数字进行异或操作，可以得到只出现一次的数字

本题中有两个只出现一次的数字，再用这种解法需要将数组分成两组，并满足以下条件：

* 两个不重复的数字需要分到不同的组
* 重复数字必须分到同一组，才能在异或的过程中抵消掉

根据异或的性质，两个数字异或结果中为 1 的 bit，表示这两个数字原码中该 bit 不同，利用这一性质我们可以将两个不重复的数字分到两组

对于重复的数字，其二进制是相同的，所以也会被分到同一组

## 代码实现
时间复杂度 O(n)，空间复杂度 O(1)

需要注意的是，**`==` 运算符优先级高于 `&`**，在判断结果是否为 0 时需要加括号，或者直接用结果当 bool 值判断
```cpp
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) 
    {
        if (nums.empty())
            return {};
        // 全员异或，得到只出现一次的 a^b
        int nXor = 0;
        for (int i : nums)
            nXor ^= i;
        // a b 不同数字异或的值必定有一个位不同，在其异或的结果中这一位为 1
        int mask = 1;
        // 从低位开始找第一个为 1 的位
        while ((nXor & mask) == 0)
            mask <<= 1;
        // 根据这一点不同，来将 a b 分到不同的组（同样的数字也会被分到同一组）
        int num1 = 0, num2 = 0;
        for (int i : nums)
        {
            if (i & mask)
                num1 ^= i;
            else
                num2 ^= i;
        }
        return {num1, num2};
    }
};
```


