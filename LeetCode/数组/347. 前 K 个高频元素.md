# 347. 前 K 个高频元素
> 来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/top-k-frequent-elements/description/

给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。

## 解题思路
解法一：计数后排序
1. 遍历数组 map 统计出现次数
2. 以出现次数大小排序，得到出现次数从多到少，返回前 k 个


解法二：桶排序
1. 遍历数组 map 统计出现次数，并记录出现次数最多的 max_cnt
2. 创建桶 buckets，每个桶中存储出现次数 == 当前下标 i 的元素，长度为 max_cnt + 1
3. 遍历 map 根据出现次数写入 buckets，最后返回出现次数前 k 的元素

**特别注意：**
- bucket 大小为出现最多次数的数字 + 1
- 由于该题只有唯一解，所以遍历 buckets 的元素入库中，一定会达到 k 个



## 代码实现
解法一：时间复杂度 O(nlogn)，空间复杂度 O(n)
```cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 统计出现次数
        map<int, int> cnt;
        for (int i : nums) {
            if (cnt.count(i) == 0) {
                cnt[i] = 1;
            }
            else {
                ++cnt[i];
            }
        }
        // 以出现次数排序
        vector<pair<int, int> > st;
        for (auto p : cnt) {
            st.push_back(pair<int,int>(p.first, p.second));
        }
        sort(st.begin(), st.end(), [](const pair<int,int>& a, const pair<int,int>& b) {
            return a.second > b.second;
        });

        // 返回前 k 个
        vector<int> ans;
        for (int i=0; i<k; ++i) {
            ans.push_back(st[i].first);
        }
        return ans;
    }
};
```

解法二：时间复杂度 O(n)，空间复杂度 O(n)
```cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 统计出现次数
        unordered_map<int, int> cnt;
        int max_cnt = 0;
        for (int i : nums) {
            if (cnt.count(i) == 0) {
                cnt[i] = 1;
            }
            else {
                ++cnt[i];
            }
            max_cnt = max(max_cnt, cnt[i]);
        }
        // 桶排序
        vector<vector<int> > buckets(max_cnt+1);
        for (auto& p : cnt) {
            buckets[p.second].push_back(p.first);
        }
        // 返回出现最多的前 k 个
        vector<int> ans;
        ans.reserve(k);
        for (auto it=buckets.rbegin(); it!=buckets.rend(); ++it) {
            if (ans.size() >= k) {
                break;
            }
            for (auto e : *it) {
                ans.push_back(e);
            }
        }
        return ans;
    }
};
```