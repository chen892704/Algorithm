# 46. 全排列
> 来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/permutations/description/

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

## 解题思路
使用回溯算法, 递归的深度遍历数组, 每次固定一个位置, 再枚举后面所有可能的分支

实际运行中相当于生成一个每层多一个分叉的树，正如全排列公式
> 对于一个长度为 n 的数组（假设元素互不重复），其排列方案数有：`n × (n−1) × (n−2) … × 2 × 1`

## 代码实现
时间复杂度 O(n!)，空间复杂度 O(n)
```cpp
class Solution {
public:
    int n = 0;
    vector<vector<int>> ans;

    void dfs(vector<int>& nums, int index) {
        // 到达最后一个数, 不需要再选择
        if (index == n-1) {
            // 记录结果
            ans.push_back(nums);
            return;
        }

        for (int i=index; i<n; ++i) {
            swap(nums[i], nums[index]);
            dfs(nums, index+1); // 以当前状态为基础, 固定下个 index 再继续递归
            // 回溯
            swap(nums[i], nums[index]);
        }
    }

    vector<vector<int>> permute(vector<int>& nums) {
        n = nums.size();
        dfs(nums, 0);
        return ans;
    }
};
```
