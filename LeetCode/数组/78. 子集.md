# 78. 子集
> 来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/subsets/description

给你一个整数数组 `nums` ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

## 解题思路
使用回溯算法, 递归的深度遍历数组
- 对于每个数字，有两种分支：选 or 不选
- 不选择则直接递归 `dfs(i+1)`
- 选择则加入结果集，继续递归 `dfs(i+1)`
- 选择分支后需要回溯，把加入结果集的删掉还原数组
- 边界条件，递归至数组末，将当前分支的结果加入 ans

*时间复杂度为 2 的 N 次方，因为相当于遍历了二叉树的所有节点*

## 代码实现
时间复杂度 O(2^n)，空间复杂度 O(n)
```cpp
class Solution {
public:
    vector<vector<int> > ans;
    vector<int> cur;
    int n = 0;

    void dfs(vector<int>& nums, int index) {
        // 边界条件，数组遍历完成
        if (index == n) {
            ans.push_back(cur);
            return;
        }

        // 当前数字 选 or 不选
        int size = cur.size();
        dfs(nums, index+1);
        cur.push_back(nums[index]); // 加到路径中
        dfs(nums, index+1);
        cur.resize(size);   // 回溯，还原路径
    }

    vector<vector<int>> subsets(vector<int>& nums) {
        n = nums.size();
        dfs(nums, 0);
        return ans;
    }
};
```
