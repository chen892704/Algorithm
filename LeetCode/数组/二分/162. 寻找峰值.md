# 162. 寻找峰值
> 来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/search-in-rotated-sorted-array/description/

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞` 。

你必须实现时间复杂度为 `O(log n)` 的算法来解决此问题。

提示：

- `1 <= nums.length <= 1000`
- `-2^31 <= nums[i] <= 2^31 - 1`
- 对于所有有效的 `i` 都有 `nums[i] != nums[i + 1]`

## 解题思路
题目要求实现 O(logN) 的解法, 首先能想到使用二分来处理, 从题中提供的条件来看, 判断二段性只能从 "分割点 mid 和左右相邻元素大小关系" 这里着手

由题设可证明：
1. 在题设条件下的数组一定存在峰值（一定有解）
    - 数组的边界可视为负无穷, 即时数组长度为 1, 唯一的那个元素即为峰值
    - 数组相邻元素必定不重复, 在 `nums[i] < nums[i±1]` 的情况下, `nums[i±1]` 的方向必定存在峰值（因为即使一直递增下去, 由于数组的边界是负无穷, 最后的元素即为峰值）
2. 二分不会错过峰值
    - 由证明 1 可知, 在以 `mid` 为分割点的数组上, 根据 `nums[mid]` 与 `nums[i±1]` 的大小关系, 可以确定其中一段满足 **必然有解** , 另一段 **可能有解, 可能无解**

综上我们可以始终选择大于边界的一端进行二分, 可以确保选择的区间一定有峰值, 并随着二分过程不断逼近峰值位置

---
参考 LC 网友评论的一段话更好的理解该题：

> 中点所在地方，可能是某座山的山峰，山的下坡处，山的上坡处，如果是山峰，最后会二分终止也会找到，关键是我们的二分方向，并不知道山峰在我们左边还是右边，送你两个字你就明白了，爬山（没错，就是带你去爬山），如果你往下坡方向走，也许可能遇到新的山峰，但是也许是一个一直下降的坡，最后到边界。但是如果你往上坡方向走，就算最后一直上的边界，由于最边界是负无穷，所以就一定能找到山峰，总的一句话，往递增的方向上，二分，一定能找到，往递减的方向只是可能找到，也许没有。

## 代码实现
时间复杂度 O(logN)，空间复杂度 O(1)
```cpp
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        if (nums.size() == 1)
            return 0;
        // 二分搜索
        int l = 0, r = nums.size()-1;
        while (l < r) {
            int mid = l + r + 1 >> 1;
            // 判断 nums[mid] 与 nums[i±1], 较大的一端必然有解
            if (nums[mid] > nums[mid-1]) {
                l = mid;
            }
            else {
                r = mid-1;
            }
        }
        return r;
    }
};
```


