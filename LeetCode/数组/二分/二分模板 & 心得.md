# 二分模板

个人理解：
- 二分是通过中间元素的一些特征, 来判断目标在数组的哪个部分, 不断逼向极值(目标元素)的一个过程
- 二分的关键在于找到数组的二段性, 即如何通过中间元素的特征判断目标在数组哪个部分

## 二分的一些特性
1. **二分的本质是「二段性」，并非单调性。只要一段满足某个性质，另一段不满足，就可以用二分**
2. **不仅仅只有满足 1/0 特性（满足/不满足）的「二段性」可以使用二分，满足 1/? 特性（一定满足/不一定满足）也可以二分**

「二分」模板其实有两套，主要是根据 `check(mid)` 函数为 `true` 时，需要调整的是 `l` 指针还是 `r` 指针来判断（指 l / r 哪个指针修改为 mid）。

## 模板一
当 `check(mid) == true` 调整的是 `l` 时：计算 `mid` 的方式应该为 `mid = l + r + 1 >> 1`
```cpp
int l = 0, r = 1000009;
while (l < r) {
    int mid = l + r + 1 >> 1;
    if (check(mid)) {
        l = mid;
    } else {
        r = mid - 1;
    }
}
// 循环结束后, l == r == index of target
// 若 target 不存在, l == r == 从大到小首个小于 target 的元素
```

## 模板二
当 `check(mid) == true` 调整的是 `r` 时：计算 `mid` 的方式应该为 `mid = l + r >> 1`
```cpp
int l = 0, r = 1000009;
while (l < r) {
    int mid = l + r >> 1;
    if (check(mid)) {
        r = mid;
    } else {
        l = mid + 1;
    }
}
// 循环结束后, l == r == index of target
// 若 target 不存在, l == r == 从小到大首个大于 target 的元素
```

## 为什么修改左边指针 left 的时候要进行 +1 操作 ?

「模板一」的 +1 操作主要是为了避免发生「死循环」，因为 >> 和 直接使用 / 一样，都属于「下取整」操作

考虑 l = 0, r = 1 的简单情况，如果不 +1 的话，l + r >> 1 等于 0 + 1 / 2，l 仍然是 0，陷入死循环

