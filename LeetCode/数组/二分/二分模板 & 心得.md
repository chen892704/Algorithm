# 二分模板

个人理解：
- 二分是通过中间元素的一些特征, 来判断目标在数组的哪个部分, 不断逼向极值(目标元素)的一个过程
- 二分的关键在于找到数组的二段性, 即如何通过中间元素的特征判断目标在数组哪个部分
- 涉及数组/矩阵中第 K 小都可以用二分猜答案的套路，转化为 "给定一个数，求数组中有多少个数比这个数小"，进而实现二分查找

## 不同开闭区间的二分写法
来自 [二分查找 红蓝染色法【基础算法精讲 04】](https://www.bilibili.com/video/BV1AP41137w7) 的思路
- l,r 初始化的区间不同，实际判断结束条件，和左右区间的迭代也不同

### 闭区间
```cpp
int lower_bound(vector<int>& nums, int target) {
    int left = 0, right = (int) nums.size() - 1; // 闭区间 [left, right]
    while (left <= right) { // 区间不为空
        // 循环不变量：
        // nums[left-1] < target
        // nums[right+1] >= target
        int mid = left + (right - left) / 2;
        if (nums[mid] >= target) {
            right = mid - 1; // 范围缩小到 [left, mid-1]
        } else {
            left = mid + 1; // 范围缩小到 [mid+1, right]
        }
    }
    // 循环结束后 left = right+1
    // 此时 nums[left-1] < target 而 nums[left] = nums[right+1] >= target
    // 所以 left 就是第一个 >= target 的元素下标
    return left;
}
```
### 半开区间
```cpp
// lower_bound 返回最小的满足 nums[i] >= target 的下标 i
// 如果数组为空，或者所有数都 < target，则返回 nums.size()
// 要求 nums 是非递减的，即 nums[i] <= nums[i + 1]
int lower_bound(vector<int>& nums, int target) {
    int left = 0, right = nums.size(); // 左闭右开区间 [left, right)
    while (left < right) { // 区间不为空
        // 循环不变量：
        // nums[left-1] < target
        // nums[right] >= target
        int mid = left + (right - left) / 2;
        if (nums[mid] >= target) {
            right = mid; // 范围缩小到 [left, mid)
        } else {
            left = mid + 1; // 范围缩小到 [mid+1, right)
        }
    }
    // 循环结束后 left = right
    // 此时 nums[left-1] < target 而 nums[left] = nums[right] >= target
    // 所以 left 就是第一个 >= target 的元素下标
    return left;
}
```
### 开区间
```cpp
// lower_bound 返回最小的满足 nums[i] >= target 的下标 i
// 如果数组为空，或者所有数都 < target，则返回 nums.size()
// 要求 nums 是非递减的，即 nums[i] <= nums[i + 1]
int lower_bound(vector<int>& nums, int target) {
    int left = -1, right = nums.size(); // 开区间 (left, right)
    while (left + 1 < right) { // 区间不为空
        // 循环不变量：
        // nums[left] < target
        // nums[right] >= target
        int mid = left + (right - left) / 2;
        if (nums[mid] >= target) {
            right = mid; // 范围缩小到 (left, mid)
        } else {
            left = mid; // 范围缩小到 (mid, right)
        }
    }
    // 循环结束后 left+1 = right
    // 此时 nums[left] < target 而 nums[right] >= target
    // 所以 right 就是第一个 >= target 的元素下标
    return right;
}
```


## 二分的一些特性
1. **二分的本质是「二段性」，并非单调性。只要一段满足某个性质，另一段不满足，就可以用二分**
2. **不仅仅只有满足 1/0 特性（满足/不满足）的「二段性」可以使用二分，满足 1/? 特性（一定满足/不一定满足）也可以二分**

「二分」模板其实有两套，主要是根据 `check(mid)` 函数为 `true` 时，需要调整的是 `l` 指针还是 `r` 指针来判断（指 l / r 哪个指针修改为 mid）。

## 模板一
当 `check(mid) == true` 调整的是 `l` 时：计算 `mid` 的方式应该为 `mid = l + r + 1 >> 1`
```cpp
int l = 0, r = 1000009;
while (l < r) {
    int mid = l + r + 1 >> 1;
    if (check(mid)) {
        l = mid;
    } else {
        r = mid - 1;
    }
}
// 循环结束后, l == r == index of target
// 若 target 不存在, l == r == 从大到小首个小于 target 的元素
```

## 模板二
当 `check(mid) == true` 调整的是 `r` 时：计算 `mid` 的方式应该为 `mid = l + r >> 1`
```cpp
int l = 0, r = 1000009;
while (l < r) {
    int mid = l + r >> 1;
    if (check(mid)) {
        r = mid;
    } else {
        l = mid + 1;
    }
}
// 循环结束后, l == r == index of target
// 若 target 不存在, l == r == 从小到大首个大于 target 的元素
```

## 为什么修改左边指针 left 的时候要进行 +1 操作 ?

「模板一」的 +1 操作主要是为了避免发生「死循环」，因为 >> 和 直接使用 / 一样，都属于「下取整」操作

考虑 l = 0, r = 1 的简单情况，如果不 +1 的话，l + r >> 1 等于 0 + 1 / 2，l 仍然是 0，陷入死循环

