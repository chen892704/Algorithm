# 137. 只出现一次的数字 II
> 来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/single-number-ii/description/

给你一个整数数组 `nums` ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。

## 解题思路
题目要求实现满足：线性时间复杂度, 空间复杂度 O(1)

- 由于数组中的元素都在 int（即 32 位整数）范围内, 因此我们可以依次计算答案的每一个二进制位是 0 还是 1

- 考虑答案的第 i 个二进制位可能为 0 或 1, 对于数组中非答案的元素, 每一个元素都出现了 3 次, 对应着第 i 个二进制位的 3 个 0 或 3 个 111, 无论是哪一种情况, 它们的和都是 3 的倍数, 因此：

- `答案的第 i 个二进制位 = 数组中所有元素的第 i 个二进制位之和 % 3`

- 对于数组中的每一个元素 x，我们使用位运算 `(x >> i) & 1` 得到 x 的第 i 个二进制位，并将它们相加再对 3 取余，得到的结果一定为 0 或 1，即为答案的第 i 个二进制位


## 代码实现
时间复杂度 O(nlogC), 空间复杂度 O(1)

`C` 是元素的数据范围，在本题中 `log⁡C = log⁡2^32 = 32`
```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        // 遍历每个元素的每一 bit
        for (int i=0; i<32; ++i) {
            int total = 0;
            // 统计所有元素第 i 位为 1 的次数
            for (int num : nums) {
                total += ((num >> i) & 1);
            }
            // 答案的第 i 个 bit 是数组中所有元素的第 i 个 bit 之和除以 3 的余数
            if (total % 3) {
                ans |= (1<<i);
            }
        }

        return ans;
    }
};
```




