# 15. 三数之和
> 来源：力扣（LeetCode）
https://leetcode.cn/problems/3sum/description

给你一个整数数组 nums ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。


## 解题思路
1. 通过枚举 i，找到与 i 之和为 0 的 j/k，本题可退化为求两数之和
2. 排序数组使其有序，通过相向双指针 j/k，三数之和与 0 比较，若 sum > 0 则 --k 缩小和，反之 ++j 扩大和，找到和为 0 的三元组
3. 注意在枚举 i/j/k 时，为了不包括重复三元组，需要跳过连续的相同数字

### 优化
1. 在枚举 i 时，当前 i+1, i+2 是剩余最小的两个数，三数之和若 > 0 则后面的数都不用遍历了（后面只会更大，无合为 0 的解）
2. 同上，n-1, n-2 是最大的两个数，三数之和若 < 0，则当前 i 不用枚举了（本轮之和都将 < 0，但后面 i 会变大，仅跳过本轮） 

## 代码实现
时间复杂度 O(n^2)，空间复杂度 O(1)
```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int> > res;
        std::sort(nums.begin(), nums.end());
        int n = nums.size();
        for (int i=0; i<n-2; ++i) {
            // 跳过相同数字
            if (i>0 && nums[i-1] == nums[i]) {
                continue;
            }

            // 当前三个最小的数之和都大于 0, 无可行解
            if (nums[i] + nums[i+1] + nums[i+2] > 0) {
                break;
            }
            // 当前数和最大两个数之和小于 0, 本轮无可行解, 跳过枚举下个数
            if (nums[i] + nums[n-1] + nums[n-2] < 0) {
                continue;
            }

            // 相向双指针, 跟 target 比较逐步缩小范围
            int j = i+1, k = n-1;
            while (j<k) {
                int sum = nums[i] + nums[j] + nums[k];
                if (sum == 0) {
                    vector<int> tmp = {nums[i], nums[j], nums[k]};
                    res.emplace_back(std::move(tmp));
                    // 跳过重复的 j,k
                    --k;
                    while (j<k && nums[k] == nums[k+1]) {
                        --k;
                    }
                    ++j;
                    while (j<k && nums[j] == nums[j-1]) {
                        ++j;
                    }
                }
                else if (sum > 0) {
                    --k;
                }
                else {
                    ++j;
                }
            }
        }
        return res;
    }
};
```
