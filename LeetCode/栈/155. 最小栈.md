# 155. 最小栈
> 来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/min-stack/description

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

`MinStack()` 初始化堆栈对象。
`void push(int val)` 将元素val推入堆栈。
`void pop()` 删除堆栈顶部的元素。
`int top()` 获取堆栈顶部的元素。
`int getMin()` 获取堆栈中的最小元素。

## 解题思路
O(1) 空间解法：
1. 栈中不存储元素值，而是存储元素和当前栈中最小值的差值
2. 入栈时，若当前元素更小（diff < 0）则更新最小值
3. 出栈时，若当前栈顶存储的差值 diff < 0，则说明最小值要出栈，根据 diff 更新栈中最小值 

**特别注意**
- 差值可能溢出，需要使用 long long
- 特判：栈空时直接返回


## 代码实现
时间复杂度 O(n)，空间复杂度 O(1)
```cpp
class MinStack {
private:
    long long min_val = INT_MIN; // 差值可能会溢出, 用 long long
    vector<long long> diffs; // 存储元素和最小值的差值

public:
    MinStack() {}
    
    void push(int val) {
        // 栈空时，当前 val 为最小值
        if (diffs.empty()) {
            min_val = val;
        }
        // 栈中实际存储的, 是当前元素和未入栈前栈中最小值的差值
        long long diff = (long long)val - min_val;
        diffs.push_back(diff);
        // 若当前元素更小, 更新最小值
        if (diff < 0) {
            min_val = val;
        }
    }
    
    void pop() {
        if (diffs.empty())
            return;

        // 出栈时，通过差值和当前最小值还原元素
        long long diff = diffs.back();
        diffs.pop_back();
        // 若差值小于 0 则表示最小值已出栈，通过差值更新栈中最小值
        if (diff < 0) {
            min_val = min_val - diff;
        }
        // 若栈空还原最小值
        if (diffs.empty()) {
            min_val = INT_MIN;
        }
    }
    
    int top() {
        if (diffs.empty())
            return 0;

        // 差值小于 0 说明当前值就是最小值
        long long diff = diffs.back();
        if (diff < 0)
            return min_val;
        // 否则通过差值还原元素
        return min_val + diff;
    }
    
    int getMin() {
        return min_val;
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```
