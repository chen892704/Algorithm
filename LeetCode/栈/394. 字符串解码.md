# 394. 字符串解码
> 来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/decode-string/description/

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。

测试用例保证输出的长度不会超过 `105`。

## 解题思路
遍历输入字符串，分类讨论：
1. 当前为字母 -- 累加入结果 res
2. 当前为数字 -- 统计数字大小 k，即重复多少次
3. 当前为括号 -- 递归解码括号中的字符串，累加入结果 res，重复 k 次


**特别注意**
- 如何统计 k：`k = k*10 + (c-'0')`
- 如何用栈模拟递归：遇到括号需要递归时，用栈记录当前 res 和 k，括号内字符串处理完了再出栈计算。这个过程跟递归一样，可能会入栈多次

## 代码实现
时间复杂度 O(n)，空间复杂度 O(n)
1. 递归解法
```cpp
class Solution {
public:
    int i = 0;    

    // 解码从 i 开始当前括号内的字符串
    string decode(string& s) {
        string res = "";
        int k = 0;
        while (i < s.size()) {
            char c = s[i];
            i++;

            // 字母: 直接记录
            if (isalpha(c)) {
                res += c;
            } 
            // 数字: 统计重复多少次
            else if (isdigit(c)) {
                k = k * 10 + (c - '0');
            } 
            // 左括号: 递归括号内的字符串
            else if (c == '[') {
                string t = decode(s);
                for (; k > 0; k--) {
                    res += t; // 把括号内的字符串重复 k 次
                }
            } 
            // 右括号：当前范围字符串解码完成
            else {
                break;
            }
        }
        return res;
    }

    string decodeString(string s) {
        return decode(s);
    }
};
```

2. 栈解法，模拟递归
```cpp
class Solution {
public:
    string decodeString(string s) {
        if (s.empty())
            return "";
        
        stack<pair<string, int> > st;
        string res = "";
        int k = 0;
        for (char c : s) {
            if (isalpha(c)) {
                res += c;
            }
            else if (isdigit(c)) {
                k = k * 10 + (c-'0');
            }
            // 模拟递归栈，把 res/k 存入栈中
            else if (c == '[') {
                st.emplace(res, k);
                res = "";
                k = 0;
            }
            // 递归完毕
            else {
                auto pre = st.top();
                string& pre_res = pre.first;
                int& pre_k = pre.second;
                st.pop();
                // 将当前(递归下层的) res 重复 k 次
                while (pre_k--) {
                    pre_res += res;
                }
                res = pre_res;
            }
        }
        
        return res;
    }
};
```
