# 1457. 二叉树中的伪回文路径
> 来源：力扣（LeetCode）
> 
> 链接：https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/description/

Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。

请你实现 Trie 类：

`Trie()` 初始化前缀树对象。
`void insert(String word)` 向前缀树中插入字符串 `word` 。
`boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
`boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。


## 解题思路
> 参考题解 [Trie Tree 的实现 (适合初学者)🌳](https://leetcode.cn/problems/implement-trie-prefix-tree/solutions/98390/trie-tree-de-shi-xian-gua-he-chu-xue-zhe-by-huwt)

Trie 树(字典树) 实际上是一个 "26 叉树"，节点结构如下：
```cpp
struct TrieNode {
    bool isEnd; // 以当前字母为结束的单词是否存在
    TrieNode* next[26]; // 字母映射表, 记录下个节点地址
};
```

## 代码实现
```cpp
class Trie {
public:
    Trie() = default;
    
    void insert(const string& word) {
        Trie* node = this;
        // 遍历单词字母确认是否存在前缀
        for (char c: word) {
            // 不存在则在 next 中, 字母对应 index 建立新 node 
            if (!node->next[c-'a']) {
                node->next[c-'a'] = new Trie();
            }
            // 继续迭代下个字母
            node = node->next[c-'a'];
        }
        // 标记当前字母是单词结束(即以该字母为结束的单词存在于树中)
        node->isEnd = true;
    }
    
    bool search(const string& word) {
        Trie* node = this;
        for (char c: word) {
            // 某个字母不存在, 未匹配
            if (!node->next[c-'a']) {
                return false;
            }
            node = node->next[c-'a'];
        }
        // 全部字母都在树中对应链存在, 判断最后一个字母是否结束(即该单词是否存在)
        return node->isEnd;
    }
    
    bool startsWith(const string& prefix) {
        Trie* node = this;
        for (char c: prefix) {
            // 某个字母不存在, 未匹配
            if (!node->next[c-'a']) {
                return false;
            }
            node = node->next[c-'a'];
        }

        // 全部匹配
        return true;
    }

private:
    bool isEnd = false;
    Trie* next[26];
};
```




