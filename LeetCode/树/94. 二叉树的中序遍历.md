# 94. 二叉树的中序遍历
> 来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/binary-tree-inorder-traversal/description/

给定一个二叉树的根节点 `root` ，返回 它的 *中序* 遍历 。


## 解题思路
两种方式，递归和非递归，非递归使用栈 `stack` 模拟

## 代码实现
递归写法
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void midOrder(vector<int>& ans, TreeNode* root) {
        if (!root) {
            return;
        }

        midOrder(ans, root->left);
        ans.push_back(root->val);
        midOrder(ans, root->right);
    }

    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        midOrder(ans, root);
        return ans;
    }
};
```

非递归写法
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        if (!root) {
            return ans;
        }
        
        // 左根右
        TreeNode* p = root;
        stack<TreeNode*> st;
        while (p || !st.empty()) {
            // 左边全部入栈
            while (p) {
                st.push(p);
                p = p->left;
            }

            // 当前栈顶即为最左的根节点
            p = st.top();
            ans.push_back(p->val);
            //cout << p->val << endl;
            // 根节点访问完了把它弹出
            st.pop();
            // 根节点访问结束，处理右子树
            //（因为此时的根节点已经是最左的非空节点，没有左子树了）
            p = p->right;
        }
        
        return ans;
    }
};
```


