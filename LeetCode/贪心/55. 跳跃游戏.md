# 55. 跳跃游戏
> 来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/jump-game/description

给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。


## 解题思路
解法一: 暴力 dfs 递归遍历所有可能性，时间复杂度 O(2^n)，会超时

解法二: dp 思想，时间复杂度 O(n)
- 遍历数组，计算从每个节点起，可达到的最远距离 farthest
- 判断当前节点是否可达（i <= farthest），若不可达说明跳不到终点
- 若当前可达，继续更新最远距离
- 若数组完成遍历说明最后的位置可达


## 代码实现
解法一: 暴力解法
```cpp
class Solution {
public:
    bool dfs(vector<int>& nums, int index) {
        //cout << index << endl;
        if (index >= nums.size()-1) {
            return true;
        }

        for (int i=1; i<=nums[index]; ++i) {
            //cout << index  << "," << i << endl;
            if (dfs(nums, index+i)) {
                return true;
            }
        }
        return false;
    }

    bool canJump(vector<int>& nums) {
        return dfs(nums, 0);
    }
};
```

解法二: dp 解法
```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int farthest = 0;
        for (int i=0; i<nums.size(); ++i) {
            // 从前面的节点跳不到当前节点, 即达不到终点
            if (i > farthest) {
                return false;
            }

            // 当前节点可达, 更新从当前节点起跳可达的最远位置
            farthest = std::max(farthest, i+nums[i]);
        }
        // 遍历完成, 说明最后的节点可达
        return true;
    }
};
```

