# 763. 划分字母区间
> 来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/partition-labels/description/

给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 "ababcc" 能够被分为 ["abab", "cc"]，但类似 ["aba", "bcc"] 或 ["ab", "ab", "cc"] 的划分是非法的。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。

返回一个表示每个字符串片段的长度的列表。


## 解题思路
一句话解释：「同一字母最多出现在一个片段中」意味着，一个片段若要包含字母 a，那么所有的字母 a 都必须在这个片段中。
1. 统计字符串中字母出现的最后一个位置
2. 使用 start, end 来记录当前分段区间，遍历字符串
    - 若区间要包含当前字母，则必须包含该字母出现的最后位置
    - 更新 end 的最远位置
3. 若 end 与当前位置相等，说明当前区间 start,end 可分割（答案需要找到最多的分段数，所以能分则分），该区间长度记录到答案中


## 代码实现
时间复杂度 O(n), 空间复杂度 O(1)
```cpp
class Solution {
public:
    vector<int> partitionLabels(string s) {
        // 统计字母出现的最后位置
        vector<int> lastPos(26, -1);
        for (int i=0; i<s.size(); ++i) {
            auto& last = lastPos[s[i]-'a'];
            last = max(last, i);
        }

        // 跳跃游戏 Ⅱ
        vector<int> ans;
        int start = 0, end = 0;
        for (int i=0; i<s.size(); ++i) {
            // 当前字母在该分段中, 则必须包括该字母出现的最后位置
            end = max(end, lastPos[s[i]-'a']);
            // 若当前位置已经是最后位置, 则可以分段 (能分则分答案需要最多的分段)
            if (i == end) {
                ans.push_back(end-start+1);
                start = end+1;
                end = start;
            }
        }

        return ans;
    }
};
```

2025.09.17: 五年后的回顾
```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size();
        int cur_left = 0, cur_right = 0, ans = 0;
        // 当右边界达到目标退出
        while (cur_right < n-1) {
            int l = cur_left, r = cur_right;
            // 遍历当前可移动区域，找到最远的右边界
            for (int i=l; i<=r; ++i) {
                // 比当前更远，更新左右边界
                if (i+nums[i] > cur_right) {
                    cur_right = i + nums[i];
                    cur_left = i;
                }
            }
            ++ans;
        }
        return ans;
    }
};
```