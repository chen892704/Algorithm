# 148. 排序链表
> 来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/sort-list/description

给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。 

## 解题思路
解法一：
直接用 set 排序，然而面试是不可能这么傻瓜的

正经解法：
> 自底向上，归并排序（自顶向下的话，用递归会有 O(nlogn) 栈空间消耗）
1. 遍历链表获得长度 len
2. 初始化 `step = 1`，从链表头节点开始，每次分割两个 step 长度的子链表，二路归并排序
3. 重复步骤 2，归并后的链表插入新链表尾部
4. `step *= 2` 继续重复步骤 2~3，直到 `step >= len`


## 代码实现
时间复杂度 O(nlogn)，空间复杂度 O(1)
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    void printList(ListNode* p) {
        string s = "";
        while (p) {
            s += to_string(p->val);
            s += ",";
            p = p->next;
        }
        cout << s << endl;
    }

    ListNode* getSlice(ListNode*& p, int step) {
        if (!p) {
            return nullptr;
        }

        ListNode *s = p;
        for (int i=0; i<step-1 && p->next; ++i) {
            p = p->next;
        }
        ListNode* t = p->next;
        p->next = nullptr;
        p = t; 
        return s;
    }

    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode head;
        ListNode *p = &head;
        while (list1 && list2) {
            if (list1->val < list2->val) {
                ListNode *p1 = list1;
                list1 = list1->next;
                p->next = p1;
            }
            else {
                ListNode *p2 = list2;
                list2 = list2->next;
                p->next = p2;
            }
            p = p->next;
        }
        if (list1) {
            p->next = list1;
        }
        else if (list2) {
            p->next = list2;
        }
        return head.next;
    }

    ListNode* sortList(ListNode* head) {
        ListNode* p = head;
        // 统计链表长度
        int len = 0;
        while (p) {
            ++len;
            p = p->next;
        }

        int step = 1;
        p = head;
        while (step < len) {
            ListNode dummy;
            ListNode* q = &dummy;
            while (p) {
                ListNode* s1 = getSlice(p, step);
                //printList(s1);
                ListNode* s2 = getSlice(p, step);
                //printList(s2);
                // 归并插入新链表尾
                q->next = mergeTwoLists(s1, s2);
                while (q->next) {
                    q = q->next;
                }
            }
            p = dummy.next;
            step *= 2;
        }

        return p;
    }
};
```
